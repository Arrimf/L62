//Второй семестр.RTTI
//Практическое занятие
//Задание :
//Создать класс, реализующий объектно - ориентированный список для объектов, производных от одного и того же базового 
//																класса.
//1.	Создайте базовый класс Shape и производные от него классы Rect, Circle…
//Подумайте, какие методы и переменные должны быть определены(переопределены) в каждом из этих классе.Обратите внимание 
//																на спецификаторы доступа и «виртуальность» методов.
//Предусмотрите возможность вычисления площади для объекта каждого производного класса.
//2.	Механизм RTTI
//Так как объекты могут быть разного типа, Вам понадобиться определение действительного типа объекта во время выполнения.
//2.1.Понятие RTTI
//Run - Time Type Information(RTTI) – динамическая идентификация типа объекта : при компиляции программы не всегда есть 
//возможность выяснить, на объект какого типа на самом деле указывает указатель на базовый класс.
//Механизм RTTI позволяет для полиморфных(то есть только при наличие в базовом классе виртуальных функций) определять 
//тип объекта во время выполнения программы.Для обеспечения этого механизма в стандартизованных версиях С++ существуют 
//	следующие понятия :
//1)	оператор dynamic_cast – для преобразования типа указателя(или ссылки) полиморфных типов;
//2)	оператор typeid – для идентификации точного типа объекта
//3)	класс type_info – тип объекта, возвращаемого typeid - оператором.
//
//2.2.Для обеспечения работы механизма RTTI :
//1)	в опциях проекта Project / Settings / C / C++ / Category / C++ Language – проверьте, что  Enable RTTI установлен
//2)	#include <typeinfo>
//
//2.3.Пример использования оператора dynamic_cast
//Оператор dynamic_cast возвращает приведенный к указанному типу указатель, если объект соответствует запрашиваемому типу, 
//иначе нулевое значение.
//void SomeFunc(CShape* p)
//{
//	if (Rect* pr = dynamic_cast<Rect*>(p))//если не нулевое значение, значит объект типа Rect
//	{
//		pr->...		//имеем право использовать приведенный указатель для обращения к членам производного класса Rect 
//      (например, к невиртуальным методам производного класса)
//	}
//}
//
//3.	Разработаем двухсвязный список, элементы которого будут являться копиями наших объектов
//Замечание : так как в списке будут фигурировать копии объектов – нам все равно, каким образом объекты - оригиналы были 
//созданы(глобальные, локальные, динамические, автоматические неименованные) = > манипулируя списком, мы несем 
//ответственность только за уничтожение копий, а оригиналы создаются и уничтожаются независимо.
//	Список реализуется двумя классами :
//3.1.Вспомогательный класс для хранения данных и связей между объектами.
//1) Модифицируйте объявление вспомогательного класса Node :
//class Node
//{
//	Node* pPrevious;	//указатель на предыдущий элемент
//	Node* pNext;		//указатель на следующий элемент
//						//подумайте: каким образом следует “хранить” данное???
//
//public:
//	//…
//};
//
//
//2) Модифицируйте реализацию методов класса Node.Подумайте: какие ранее разработанные Вами методы и каким образом 
//		следует изменить ? ? ?
//
//3.2.Основной класс, реализующий список
//Теперь вспомогательный класс Node можно использовать при создании связного списка из объектов, производных от Shape 
//													- создадим еще один класс для реализации списка – List.
//
//1)	Модифицируйте объявление класса
//2)	Модифицируйте реализацию методов
//
//
//Подсказка : скорее всего Вам понадобится для реализации метода Remove() в классе Shape и производных классах перегрузить
//											оператор == или != (возможно следует сделать его виртуальным!)
//
//	4.	Сортировка
//	Напишите для класса List сортировку по возрастанию площади объекта(по цвету, по удалению от начала координат…).
//	5.	Вывод списка в файл и чтение из файла
//
//	1) Результаты сортировки выведите в файл.Для файловых операций воспользуйтесь потоком ofstream.
//	Пример вывода в файл :


//#include <tchar.h>
#include <iostream>
#include <conio.h>
#include"List.h"
//#include "Shape.h"

//#define _CRT_SECURE_NO_WARNINGS
#define	  stop __asm nop
#define _CLS system("cls");
#define _SP system("pause");
//using namespace std;

void main() {
	List L8;

	List l;
	Circle* pc = new Circle(2,5);
	l.AddToTail(*pc);
	delete pc;	
	l.AddToTail(Circle(4, 1, 1, colour::BLUE));
	l.AddToTail(Rect(3, 5, 2, 6));

	l.AddToTail(Circle(1, 1));
	l.AddToHead(Rect(3, 5, 1, 3, colour::GREEN));

	List L2(l);

	List L3(std::move(L2));
	std::cout << L2;
	std::cout << L3;
	_SP
 	L3.SortP(&Shape::GetArea);
	//L3.SortP([&Shape::](Shape:: colour col)->double {return colour};
	L3.FindRemoveShape(Circle(1, 1/*,0,colour::GREEN*/));
	std::cout << L3;
	_SP
	L3.SortP(&Shape::OffsetZero);
	std::cout << L3;
	_SP
	
	_SP



}